/*!
 * Banquette Validation v0.0.0 (CommonJS)
 * (c) 2022-2022 Julien Pinto
 * Released under Apache License, Version 2.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _tslib = require('../_virtual/_tslib.js');
var inject_decorator = require('@banquette/dependency-injection/_cjs/dev/decorator/inject.decorator');
var module_decorator = require('@banquette/dependency-injection/_cjs/dev/decorator/module.decorator');
var injector = require('@banquette/dependency-injection/_cjs/dev/injector');
var usage_exception = require('@banquette/exception/_cjs/dev/usage.exception');
var constants = require('@banquette/http/_cjs/dev/constants');
var requestCanceled_exception = require('@banquette/http/_cjs/dev/exception/request-canceled.exception');
var httpRequest = require('@banquette/http/_cjs/dev/http-request');
var httpRequest_factory = require('@banquette/http/_cjs/dev/http-request.factory');
var http_service = require('@banquette/http/_cjs/dev/http.service');
var extend = require('@banquette/utils-object/_cjs/dev/extend');
var ensureArray = require('@banquette/utils-type/_cjs/dev/ensure-array');
var isFunction = require('@banquette/utils-type/_cjs/dev/is-function');
var isObject = require('@banquette/utils-type/_cjs/dev/is-object');
var isString = require('@banquette/utils-type/_cjs/dev/is-string');
var isType = require('@banquette/utils-type/_cjs/dev/is-type');
var isUndefined = require('@banquette/utils-type/_cjs/dev/is-undefined');
var constant = require('../constant.js');
var createValidator = require('../create-validator.js');

// Symbol used to indicate the payload should be generated by the validator itself.
// More stable to use a symbol than to use "null" or "undefined".
var AutoPayloadSymbol = Symbol();
/**
 * Do a remote validation.
 */
var AjaxValidator = /** @class */ (function () {
    function AjaxValidator(http) {
        var _this = this;
        this.http = http;
        this.message = 'Invalid value.';
        this.type = 'ajax';
        this.responseHandler = function (response, result) {
            if (response.isError) {
                result.fail(response.error);
            }
            else if (Math.floor(response.httpStatusCode * 0.01) !== 2) {
                result.addViolation(_this.type, _this.message);
            }
        };
    }
    /**
     * @inheritDoc
     */
    AjaxValidator.prototype.validate = function (context) {
        var _this = this;
        if (!isType.isType(this.requestFactory, isFunction.isFunction)) {
            throw new usage_exception.UsageException('You must define a request factory.');
        }
        var request = this.requestFactory(context.value);
        if (request.payload === AutoPayloadSymbol) {
            request.payload = isObject.isObject(context.value) ? context.value : { value: context.value };
        }
        var response = this.http.send(request);
        var promiseWrapper = new Promise(function (resolve, reject) {
            response.promise.then(function () {
                _this.responseHandler(response, context.result);
                resolve(context);
            }).catch(function (reason) {
                if (reason.error instanceof requestCanceled_exception.RequestCanceledException) {
                    context.result.cancel();
                }
                _this.responseHandler(response, context.result);
                reject(reason.error);
            });
        });
        context.result.delayResponse(promiseWrapper, function () {
            //
            // DO NOT shorten this to:
            // `context.result.delayResponse(promiseWrapper, response.request.cancel)`
            // Because the call context will be incorrect.
            //
            // To make it a one liner we could use a proxy:
            // `context.result.delayResponse(promiseWrapper, proxy(response.request.cancel, response.request))`
            //
            // But it's slower and uglier, so its good like that.
            //
            response.request.cancel();
        });
        return context.result;
    };
    AjaxValidator = _tslib.__decorate([
        module_decorator.Module(),
        _tslib.__param(0, inject_decorator.Inject(http_service.HttpService)),
        _tslib.__metadata("design:paramtypes", [http_service.HttpService])
    ], AjaxValidator);
    return AjaxValidator;
}());
function Ajax(requestFactory, responseHandler, options) {
    if (options === void 0) { options = {}; }
    var isFactoryConfig = function (value) { return isObject.isObject(value); };
    var instance = injector.Injector.Get(AjaxValidator);
    if (requestFactory instanceof httpRequest.HttpRequest) {
        var userRequest_1 = requestFactory;
        requestFactory = function () { return userRequest_1.clone(); };
    }
    else {
        if (isString.isString(requestFactory)) {
            requestFactory = { url: requestFactory, payload: AutoPayloadSymbol };
        }
        if (isFactoryConfig(requestFactory)) {
            var userRequestFactory_1 = requestFactory;
            requestFactory = function () { return httpRequest_factory.HttpRequestFactory.Create(extend.extend({
                method: constants.HttpMethod.POST,
                payload: AutoPayloadSymbol
            }, userRequestFactory_1)); };
        }
    }
    instance.requestFactory = requestFactory;
    if (!isUndefined.isUndefined(responseHandler)) {
        instance.responseHandler = responseHandler;
    }
    if (!isUndefined.isUndefined(options.message)) {
        instance.message = options.message;
    }
    if (!isUndefined.isUndefined(options.type)) {
        instance.type = options.type;
    }
    return createValidator.createValidator(instance, [constant.ASYNC_TAG].concat(ensureArray.ensureArray(options.tags)), ensureArray.ensureArray(options.groups));
}

exports.Ajax = Ajax;
exports.AjaxValidator = AjaxValidator;
exports.AutoPayloadSymbol = AutoPayloadSymbol;
