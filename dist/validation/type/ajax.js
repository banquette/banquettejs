/*!
 * Banquette Validation v0.0.0 (ESM)
 * (c) 2022-2022 Julien Pinto
 * Released under Apache License, Version 2.0
 */
import { __decorate, __param, __metadata } from '../_virtual/_tslib.js';
import { Inject } from '@banquette/dependency-injection/decorator/inject.decorator';
import { Module } from '@banquette/dependency-injection/decorator/module.decorator';
import { Injector } from '@banquette/dependency-injection/injector';
import { UsageException } from '@banquette/exception/usage.exception';
import { HttpMethod } from '@banquette/http/constants';
import { RequestCanceledException } from '@banquette/http/exception/request-canceled.exception';
import { HttpRequest } from '@banquette/http/http-request';
import { HttpRequestFactory } from '@banquette/http/http-request.factory';
import { HttpService } from '@banquette/http/http.service';
import { extend } from '@banquette/utils-object/extend';
import { ensureArray } from '@banquette/utils-type/ensure-array';
import { isFunction } from '@banquette/utils-type/is-function';
import { isObject } from '@banquette/utils-type/is-object';
import { isString } from '@banquette/utils-type/is-string';
import { isType } from '@banquette/utils-type/is-type';
import { isUndefined } from '@banquette/utils-type/is-undefined';
import { ASYNC_TAG } from '../constant.js';
import { createValidator } from '../create-validator.js';

// Symbol used to indicate the payload should be generated by the validator itself.
// More stable to use a symbol than to use "null" or "undefined".
var AutoPayloadSymbol = Symbol();
/**
 * Do a remote validation.
 */
var AjaxValidator = /** @class */ (function () {
    function AjaxValidator(http) {
        var _this = this;
        this.http = http;
        this.message = 'Invalid value.';
        this.type = 'ajax';
        this.responseHandler = function (response, result) {
            if (response.isError) {
                result.fail(response.error);
            }
            else if (Math.floor(response.httpStatusCode * 0.01) !== 2) {
                result.addViolation(_this.type, _this.message);
            }
        };
    }
    /**
     * @inheritDoc
     */
    AjaxValidator.prototype.validate = function (context) {
        var _this = this;
        if (!isType(this.requestFactory, isFunction)) {
            throw new UsageException('You must define a request factory.');
        }
        var request = this.requestFactory(context.value);
        if (request.payload === AutoPayloadSymbol) {
            request.payload = isObject(context.value) ? context.value : { value: context.value };
        }
        var response = this.http.send(request);
        var promiseWrapper = new Promise(function (resolve, reject) {
            response.promise.then(function () {
                _this.responseHandler(response, context.result);
                resolve(context);
            }).catch(function (reason) {
                if (reason.error instanceof RequestCanceledException) {
                    context.result.cancel();
                }
                _this.responseHandler(response, context.result);
                reject(reason.error);
            });
        });
        context.result.delayResponse(promiseWrapper, function () {
            //
            // DO NOT shorten this to:
            // `context.result.delayResponse(promiseWrapper, response.request.cancel)`
            // Because the call context will be incorrect.
            //
            // To make it a one liner we could use a proxy:
            // `context.result.delayResponse(promiseWrapper, proxy(response.request.cancel, response.request))`
            //
            // But it's slower and uglier, so its good like that.
            //
            response.request.cancel();
        });
        return context.result;
    };
    AjaxValidator = __decorate([
        Module(),
        __param(0, Inject(HttpService)),
        __metadata("design:paramtypes", [HttpService])
    ], AjaxValidator);
    return AjaxValidator;
}());
function Ajax(requestFactory, responseHandler, options) {
    if (options === void 0) { options = {}; }
    var isFactoryConfig = function (value) { return isObject(value); };
    var instance = Injector.Get(AjaxValidator);
    if (requestFactory instanceof HttpRequest) {
        var userRequest_1 = requestFactory;
        requestFactory = function () { return userRequest_1.clone(); };
    }
    else {
        if (isString(requestFactory)) {
            requestFactory = { url: requestFactory, payload: AutoPayloadSymbol };
        }
        if (isFactoryConfig(requestFactory)) {
            var userRequestFactory_1 = requestFactory;
            requestFactory = function () { return HttpRequestFactory.Create(extend({
                method: HttpMethod.POST,
                payload: AutoPayloadSymbol
            }, userRequestFactory_1)); };
        }
    }
    instance.requestFactory = requestFactory;
    if (!isUndefined(responseHandler)) {
        instance.responseHandler = responseHandler;
    }
    if (!isUndefined(options.message)) {
        instance.message = options.message;
    }
    if (!isUndefined(options.type)) {
        instance.type = options.type;
    }
    return createValidator(instance, [ASYNC_TAG].concat(ensureArray(options.tags)), ensureArray(options.groups));
}

export { Ajax, AjaxValidator, AutoPayloadSymbol };
